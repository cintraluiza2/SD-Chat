<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <title>Teste WebSocket Chat-API</title>
  <style>
    /* ======== RESET SUAVE ======== */
    * {
      box-sizing: border-box;
    }

    body {
      font-family: "Segoe UI", Arial, sans-serif;
      margin: 0;
      background: #eef1f5;
      color: #333;
    }

    /* ======== T√çTULO ======== */
    #app-title {
      text-align: center;
      margin: 20px 0 10px;
      font-size: 32px;
      font-weight: 700;
      color: #2c3e50;
    }

    /* ======== SE√á√ÉO DE LOGIN / CADASTRO ======== */
    #login-area,
    #register-area {
      background: white;
      max-width: 400px;
      margin: 20px auto;
      padding: 20px 25px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    input {
      width: 100%;
      padding: 10px;
      margin: 8px 0 15px;
      border: 1px solid #ccc;
      border-radius: 8px;
      transition: 0.2s;
    }

    input:focus {
      outline: none;
      border-color: #4a90e2;
      box-shadow: 0 0 4px rgba(74, 144, 226, 0.4);
    }

    button {
      padding: 10px 18px;
      border: none;
      background: #4a90e2;
      color: white;
      border-radius: 8px;
      cursor: pointer;
      transition: 0.2s;
      font-weight: 600;
    }

    button:hover {
      background: #337acc;
    }

    /* ======== TOKEN BOX ======== */
    #token-box {
      max-width: 900px;
      margin: 10px auto;
      background: #dceefd;
      border: 1px solid #9ec7f3;
      color: #1a3b5d;
      padding: 12px;
      border-radius: 8px;
      font-size: 14px;
      word-break: break-all;
    }

    /* ======== LISTA DE CONVERSAS ======== */
    #conversation-area {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      padding: 20px 25px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    #conversations-list li {
      padding: 8px 12px;
      margin-bottom: 6px;
      background: #f6f7f9;
      border-radius: 8px;
      cursor: pointer;
      transition: 0.2s;
    }

    #conversations-list li:hover {
      background: #e9eef6;
    }

    /* ======== √ÅREA DO CHAT ======== */
    #chat-area {
      display: none;
      flex-direction: row;
      gap: 30px;
      align-items: flex-start;
      width: 100%;
      max-width: 1000px;
      margin: 25px auto;
    }

    /* Painel principal */
    .chat-panel {
      flex: 3;
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    /* Lista de mensagens - Estilo WhatsApp */
    #chat {
      border: none;
      height: 350px;
      overflow-y: auto;
      margin-bottom: 15px;
      background: #efeae2;
      background-image: 
        repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,255,255,.03) 10px, rgba(255,255,255,.03) 20px);
      border-radius: 12px;
      padding: 15px;
    }

    #messages {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
    }

    /* ======== BAL√ïES DE MENSAGEM ESTILO WHATSAPP ======== */
    #messages li {
      margin-bottom: 8px;
      padding: 10px 14px;
      max-width: 65%;
      border-radius: 8px;
      line-height: 1.5em;
      word-wrap: break-word;
      position: relative;
      clear: both;
    }

    /* Minhas mensagens - Alinhadas √† DIREITA (verde WhatsApp) */
    .me {
      background: #dcf8c6;
      color: #000;
      align-self: flex-end;
      margin-left: auto;
      border-bottom-right-radius: 2px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      padding: 10px 14px;
      padding-bottom: 28px !important; /* For√ßa espa√ßo embaixo para o status */
      position: relative;
      min-height: 55px;
    }
    
    /* Texto da mensagem com margem inferior */
    .me .message-text {
      display: block;
      margin-bottom: 12px !important; /* For√ßa espa√ßo entre texto e status */
      padding-right: 5px;
    }
    
    /* Status de leitura (checkmarks) - mais vis√≠vel e afastado */
    .read-status {
      position: absolute;
      bottom: 6px;
      right: 10px;
      font-size: 14px; /* Maior */
      color: #8696a0; /* Cinza mais forte */
      display: flex;
      align-items: center;
      gap: 1px;
      font-weight: bold;
    }
    
    .read-status.read {
      color: #53bdeb; /* Azul WhatsApp mais forte */
      font-size: 15px; /* Ainda maior quando lido */
    }

    /* Mensagem de outros - Alinhadas √† ESQUERDA (branco) */
    .other {
      background: #ffffff;
      color: #000;
      align-self: flex-start;
      margin-right: auto;
      border-bottom-left-radius: 2px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    /* Mensagens do sistema (centralizadas) */
    .system {
      background: #e1f3fb;
      color: #54656f;
      font-style: italic;
      font-size: 13px;
      align-self: center;
      max-width: 80%;
      text-align: center;
      padding: 6px 12px;
      margin: 4px 0;
    }

    /* Input do chat */
    #msg {
      width: 78%;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
    }

    .chat-panel button {
      width: 20%;
    }

    /* ======== PARTICIPANTES ======== */
    .participants-panel {
      flex: 1;
      background: white !important;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      padding: 20px;
      height: 400px;
      overflow-y: auto;
    }

    /* ======== BOT√ÉO VOLTAR ======== */
    #voltar-btn {
      display: none;
      background: #777;
      margin: 10px auto;
      display: block;
    }

    #voltar-btn:hover {
      background: #555;
    }

    /* ======== SCROLLBAR BONITA ======== */
    #chat::-webkit-scrollbar,
    .participants-panel::-webkit-scrollbar {
      width: 8px;
    }

    #chat::-webkit-scrollbar-thumb,
    .participants-panel::-webkit-scrollbar-thumb {
      background: #c7c7c7;
      border-radius: 6px;
    }

    /* ======== RESPONSIVO ======== */
    @media (max-width: 800px) {
      #chat-area {
        flex-direction: column;
      }

      .participants-panel {
        width: 100%;
        height: auto;
      }

      #msg {
        width: 100%;
        margin-bottom: 10px;
      }

      .chat-panel button {
        width: 100%;
      }
    }
  </style>
</head>

<body>
  <script>
    // Detectar qualquer tentativa de sair da p√°gina
    window.addEventListener('beforeunload', function(e) {
      console.error('üö® P√ÅGINA TENTANDO DESCARREGAR!');
      console.trace();
    });
    
    // Detectar erros n√£o capturados
    window.addEventListener('error', function(e) {
      console.error('üî¥ ERRO GLOBAL:', e.message, e.filename, e.lineno);
      alert('ERRO: ' + e.message);
    });
  </script>
  <h2 id="app-title">SD-Chat</h2>


  <div id="login-area">
    <h3>Login</h3>
    <input id="username" placeholder="Nome de usu√°rio" />
    <input id="password" type="password" placeholder="Senha" />
    <button onclick="login()">Entrar</button>
    <button onclick="showRegister()">Cadastrar</button>
    <div id="login-status"></div>
  </div>
  <div id="register-area" style="display:none;">
    <h3>Cadastro</h3>
    <input id="reg-username" placeholder="Nome de usu√°rio" />
    <input id="reg-password" type="password" placeholder="Senha" />
    <button onclick="register()">Cadastrar</button>
    <button onclick="showLogin()">Voltar</button>
    <div id="register-status"></div>
  </div>
  <div id="token-box"></div>

  <div id="conversation-area" style="display:none;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
      <h3 style="margin: 0;">üí¨ Conversas</h3>
      <button onclick="logout()" style="background: #e74c3c; padding: 8px 12px; font-size: 14px;">üö™ Logout</button>
    </div>
    
    <h3>Criar conversa</h3>
    <input id="participants" placeholder="Participantes (separados por v√≠rgula)" />
    <select id="conv-type">
      <option value="private">Privada</option>
      <option value="group">Grupo</option>
    </select>
    <button onclick="createConversation()">Criar</button>
    <div id="conv-status"></div>
    <hr>
    
    <h3>üë• Usu√°rios Dispon√≠veis</h3>
    <button onclick="loadOnlineUsers()">Atualizar Usu√°rios Online</button>
    <ul id="online-users-list" style="margin-top: 10px;"></ul>
    <hr>
    
    <h3>Minhas conversas</h3>
    <button onclick="loadConversations()" style="margin-bottom: 10px;">Atualizar Conversas</button>
    <ul id="conversations-list"></ul>
  </div>

  <div id="chat-area">
    <div class="chat-panel">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <h3>Chat</h3>
        <button onclick="voltarParaConversas()" style="background: #3498db; padding: 8px 15px; font-size: 14px;">‚Üê Voltar</button>
      </div>
      <div>Conversa ID: <span id="conv-id"></span></div>
      <div id="chat">
        <ul id="messages"></ul>
      </div>
      <div style="display: flex; gap: 10px; margin-top: 10px;">
        <input id="msg" placeholder="Digite sua mensagem" style="flex: 1;" />
        <button onclick="sendMessage()">Enviar Mensagem</button>
        <button onclick="triggerFileInput()" style="background: #27ae60;">üìé Arquivo</button>
        <input id="file-input" type="file" style="display: none;" onchange="handleFileSelect(event)" />
      </div>
    </div>
    <div class="participants-panel">
      <h4>üë• Participantes</h4>
      <ul id="participants-list"></ul>
    </div>
  </div>

  <script>
    console.log('üöÄ P√ÅGINA CARREGADA EM:', new Date().toISOString());
    console.log('üîç Performance navigation type:', performance.navigation.type);
    // 0 = navega√ß√£o normal, 1 = reload, 2 = back/forward
    
    // Tentar restaurar sess√£o do localStorage
    let token = localStorage.getItem('chat_token');
    let username = localStorage.getItem('chat_username');
    let conversationId = localStorage.getItem('chat_conversationId') ? parseInt(localStorage.getItem('chat_conversationId')) : null;
    let ws = null;
    let presenceInterval = null;
    let readStatusInterval = null; // Intervalo para atualizar status de leitura

    console.log('üîç Vari√°veis inicializadas - conversationId:', conversationId, 'type:', typeof conversationId);

    // Se tem sess√£o salva, restaurar automaticamente
    if (token && username) {
      console.log('‚úÖ Restaurando sess√£o do localStorage para:', username);
      document.getElementById('login-area').style.display = 'none';
      document.getElementById('login-status').innerText = '';
      document.getElementById('app-title').innerText = `üéØ Chat - ${username}`;
      
      if (conversationId) {
        // Restaurar conversa diretamente
        console.log('‚úÖ Restaurando conversa:', conversationId, 'type:', typeof conversationId);
        document.getElementById('conversation-area').style.display = 'none';
        document.getElementById('chat-area').style.display = 'flex';
        document.getElementById('conv-id').innerText = conversationId;
        connectWS();
        loadMessages();
        loadParticipants();
        loadOnlineUsers();
      } else {
        // Mostrar lista de conversas
        document.getElementById('conversation-area').style.display = '';
        loadConversations();
      }
    }
    let heartbeatInterval = null;

    // Notifica presen√ßa ao servidor quando usuario faz login
    // ATUALIZA√á√ÉO: Presen√ßa agora √© gerenciada via WebSocket (Conex√£o = Online, Desconex√£o = Offline)
    // N√£o precisamos mais de polling ou heartbeat manual

    /* 
    function setUserOnline() { ... }
    function startHeartbeat() { ... }
    function stopHeartbeat() { ... }
    function setUserOffline() { ... }
    */



    function login() {
      username = document.getElementById('username').value.trim();
      const password = document.getElementById('password').value;
      if (!username || !password) {
        document.getElementById('login-status').innerText = 'Preencha usu√°rio e senha.';
        return;
      }
      fetch('http://localhost:3003/api/v1/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      })
        .then(async res => {
          if (!res.ok) {
            const err = await res.json();
            document.getElementById('login-status').innerText = err.error || 'Erro ao autenticar';
            return null;
          }
          return res.json();
        })
        .then(data => {
          if (!data) return;
          token = data.token;
          
          // Salvar no localStorage
          localStorage.setItem('chat_token', token);
          localStorage.setItem('chat_username', username);
          
          document.getElementById('login-status').innerText = 'Autenticado!';
          document.getElementById('login-area').style.display = 'none';
          document.getElementById('conversation-area').style.display = '';
          document.getElementById('register-area').style.display = 'none';
          document.getElementById('app-title').innerText = `üéØ ${username}`;
          const tokenBox = document.getElementById('token-box');
          tokenBox.innerHTML = `<b>Token JWT:</b><br><span>${token}</span>`;
          tokenBox.style.display = 'block';
          
          // Conectar WebSocket imediatamente (isso define como ONLINE)
          connectWS();
          
          // Carregar conversas e usu√°rios dispon√≠veis (apenas carga inicial)
          loadConversations();
          loadOnlineUsers();
          
          // Carregar mensagens pendentes
          loadPendingMessages();
          
          // N√ÉO usar interval - causa problemas ap√≥s upload
          // Se quiser, s√≥ carrega uma vez
          // presenceInterval = setInterval(() => {
          //   loadOnlineUsers();
          // }, 5000);
        });
    }

    function showRegister() {
      document.getElementById('login-area').style.display = 'none';
      document.getElementById('register-area').style.display = '';
      document.getElementById('register-status').innerText = '';
    }
    function showLogin() {
      document.getElementById('register-area').style.display = 'none';
      document.getElementById('login-area').style.display = '';
      document.getElementById('login-status').innerText = '';
    }
    function register() {
      const username = document.getElementById('reg-username').value.trim();
      const password = document.getElementById('reg-password').value;
      if (!username || !password) {
        document.getElementById('register-status').innerText = 'Preencha usu√°rio e senha.';
        return;
      }
      fetch('http://localhost:3003/api/v1/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      })
        .then(async res => {
          if (!res.ok) {
            const err = await res.json();
            document.getElementById('register-status').innerText = err.error || 'Erro ao cadastrar';
            return null;
          }
          return res.json();
        })
        .then(data => {
          if (!data) return;
          document.getElementById('register-status').innerText = 'Cadastro realizado! Fa√ßa login.';
          // Limpar campos
          document.getElementById('reg-username').value = '';
          document.getElementById('reg-password').value = '';
        });
    }

    function loadConversations() {
      fetch(`http://localhost:3003/api/v1/users/${username}/conversations`, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        }
      })
        .then(res => {
          if (!res.ok) {
            if (res.status === 401) {
              console.error("401 em loadConversations - ignorando logout");
              // logout();
            }
            throw new Error(`HTTP ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          const ul = document.getElementById('conversations-list');
          ul.innerHTML = '';
          (data.conversations || []).forEach(conv => {
            const li = document.createElement('li');
            li.innerHTML = `<b>${conv.type === 'group' ? 'üë• Grupo' : 'üí¨ Privada'}</b> - ID: ${conv.id}`;
            li.style.cursor = 'pointer';
            li.style.padding = '10px';
            li.style.margin = '8px 0';
            li.style.background = '#e8f4f8';
            li.style.borderRadius = '6px';
            li.style.transition = '0.2s';
            li.onmouseover = () => li.style.background = '#d0e8f2';
            li.onmouseout = () => li.style.background = '#e8f4f8';
            li.onclick = () => selectConversation(conv.id);
            ul.appendChild(li);
          });
        })
        .catch(err => {
          console.error('Erro ao carregar conversas:', err);
          console.error('Stack completo:', err.stack);
          // N√£o fazer logout aqui, apenas registrar
        });
    }

    function loadOnlineUsers() {
      if (!token) {
        console.error('Token n√£o dispon√≠vel');
        const ul = document.getElementById('online-users-list');
        ul.innerHTML = '<li style="color: red;">‚ùå Fa√ßa login primeiro</li>';
        return;
      }

      console.log('Carregando usu√°rios online...');
      fetch(`http://localhost:3003/api/v1/users`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        }
      })
        .then(res => {
          console.log('Response status:', res.status);
          if (!res.ok) {
            return res.json().then(err => {
              throw new Error(`HTTP ${res.status}: ${err.error || res.statusText}`);
            });
          }
          return res.json();
        })
        .then(data => {
          console.log('Dados recebidos:', data);
          const ul = document.getElementById('online-users-list');
          ul.innerHTML = '';
          const users = data.users || [];
          
          console.log('Total de usu√°rios:', users.length);
          
          if (users.length === 0) {
            ul.innerHTML = '<li style="color: #999;">Nenhum usu√°rio dispon√≠vel</li>';
            return;
          }
          
          users.forEach(user => {
            if (user.username === username) {
              console.log('Pulando usu√°rio atual:', user.username);
              return; // N√£o mostra a si mesmo
            }
            
            const status = user.is_online ? 'üü¢' : 'üî¥';
            const statusText = user.is_online ? 'Online' : 'Offline';
            
            const li = document.createElement('li');
            li.innerHTML = `${status} ${user.username}`;
            li.style.cursor = 'pointer';
            li.style.padding = '10px';
            li.style.margin = '8px 0';
            li.style.background = user.is_online ? '#d4edda' : '#f8d7da';
            li.style.borderRadius = '6px';
            li.style.transition = '0.2s';
            li.onmouseover = () => li.style.background = user.is_online ? '#c3e6cb' : '#f5c6cb';
            li.onmouseout = () => li.style.background = user.is_online ? '#d4edda' : '#f8d7da';
            li.style.opacity = user.is_online ? '1' : '0.7';
            
            // Permite clicar mesmo que esteja offline - as mensagens ser√£o salvas como pendentes
            li.onclick = () => startPrivateChat(user.username);
            
            const tooltip = document.createElement('small');
            tooltip.style.display = 'block';
            tooltip.style.fontSize = '12px';
            tooltip.style.color = '#666';
            tooltip.style.marginTop = '3px';
            tooltip.innerText = user.is_online ? 'Clique para iniciar conversa' : 'Clique para enviar mensagem (ser√° entregue ao fazer login)';
            li.appendChild(tooltip);
            
            ul.appendChild(li);
          });
          
          console.log('Usu√°rios carregados com sucesso');
        })
        .catch(err => {
          console.error('Erro ao carregar usu√°rios:', err);
          if (err.message.includes('401')) {
            console.error("401 em loadOnlineUsers - ignorando logout");
            // logout();
          } else {
            const ul = document.getElementById('online-users-list');
            ul.innerHTML = `<li style="color: red;">‚ùå ${err.message}</li>`;
          }
        });
    }

    function startPrivateChat(otherUser) {
      // Normalizar participantes: ordenar alfabeticamente para compara√ß√£o consistente
      const participants = [username, otherUser].sort();
      
      console.log('üîç Verificando se j√° existe conversa privada com:', otherUser);
      console.log('   Participantes normalizados:', participants);
      
      // Primeiro, buscar todas as conversas para verificar se j√° existe
      fetch(`http://localhost:3003/api/v1/users/${username}/conversations`, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        }
      })
        .then(res => res.json())
        .then(data => {
          const conversations = data.conversations || [];
          console.log('üìã Total de conversas encontradas:', conversations.length);
          
          // Procurar conversa privada existente com esse usu√°rio
          const existingConv = conversations.find(conv => {
            const convParticipants = (conv.participants || []).sort();
            console.log('  Comparando:', {
              buscando: participants,
              encontrado: convParticipants,
              id: conv.id
            });
            
            // Verifica se √© conversa privada (2 participantes) exatamente iguais
            if (convParticipants.length !== 2) return false;
            const match = participants[0] === convParticipants[0] && participants[1] === convParticipants[1];
            if (match) console.log('  ‚úÖ MATCH encontrado! ID:', conv.id);
            return match;
          });
          
          if (existingConv) {
            // Conversa j√° existe, abre ela
            console.log('‚úÖ Conversa privada j√° existe com ID:', existingConv.id, '- Abrindo...');
            selectConversation(existingConv.id);
            
            // Mostra mensagem informando se o usu√°rio est√° offline
            const onlineStatus = document.querySelector(`[data-user="${otherUser}"]`);
            if (onlineStatus && !onlineStatus.textContent.includes('üü¢')) {
              addSystemMsg(`‚ö†Ô∏è ${otherUser} est√° offline. Suas mensagens ser√£o entregues quando fizer login.`);
            }
          } else {
            // N√£o existe, criar nova conversa privada
            console.log('üìù Criando nova conversa privada com:', otherUser);
            fetch('http://localhost:3003/api/v1/conversations', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + token
              },
              body: JSON.stringify({ participants, type: 'private' })
            })
              .then(res => {
                if (!res.ok) {
                  if (res.status === 401) {
                      console.error("401 em startPrivateChat - ignorando logout");
                      // logout();
                  }
                  throw new Error(`HTTP ${res.status}`);
                }
                return res.json();
              })
              .then(data => {
                conversationId = data.conversationId;
                localStorage.setItem('chat_conversationId', conversationId);
                console.log('‚úÖ Nova conversa privada criada:', conversationId);
                document.getElementById('conv-id').innerText = conversationId;
                document.getElementById('conversation-area').style.display = 'none';
                document.getElementById('chat-area').style.display = 'flex';
                connectWS();
                loadMessages();
                loadParticipants();
                // Mostra mensagem informando se o usu√°rio est√° offline
                const onlineStatus = document.querySelector(`[data-user="${otherUser}"]`);
                if (onlineStatus && !onlineStatus.textContent.includes('üü¢')) {
                  addSystemMsg(`‚ö†Ô∏è ${otherUser} est√° offline. Suas mensagens ser√£o entregues quando fizer login.`);
                }
              })
              .catch(err => {
                console.error('Erro ao criar conversa:', err);
                alert('Erro ao abrir conversa: ' + err.message);
              });
          }
        })
        .catch(err => {
          console.error('Erro ao verificar conversas:', err);
          alert('Erro ao verificar conversas: ' + err.message);
        });
    }

    function selectConversation(id) {
      conversationId = id;
      localStorage.setItem('chat_conversationId', id);
      document.getElementById('conv-id').innerText = conversationId;
      document.getElementById('conversation-area').style.display = 'none';
      document.getElementById('chat-area').style.display = 'flex';
      connectWS();
      loadMessages();
      loadParticipants();
      
      // Inicia atualiza√ß√£o autom√°tica do status de leitura
      startReadStatusUpdates();
    }

    // Fun√ß√£o para voltar para a lista de conversas
    function voltarParaConversas() {
      // Para atualiza√ß√£o de status de leitura
      stopReadStatusUpdates();
      
      // Fecha WebSocket
      if (ws) {
        ws.close();
        ws = null;
      }
      
      conversationId = null;
      document.getElementById('messages').innerHTML = '';
      document.getElementById('participants-list').innerHTML = '';
      document.getElementById('msg').value = '';
      
      document.getElementById('chat-area').style.display = 'none';
      document.getElementById('conversation-area').style.display = '';
      
      loadConversations();
      // N√ÉO carregar usu√°rios online ao fazer logout
      // loadOnlineUsers();
    }

    // Carrega mensagens pendentes que chegaram enquanto estava offline
    function loadPendingMessages() {
      if (!token) return;
      
      fetch('http://localhost:3003/api/v1/pending-messages', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        }
      })
        .then(res => {
          if (!res.ok) {
            if (res.status === 401) {
                console.error("401 em loadPendingMessages - ignorando logout");
                // logout();
            }
            throw new Error(`HTTP ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          const pendingMessages = data.pendingMessages || [];
          
          if (pendingMessages.length === 0) {
            console.log('Nenhuma mensagem pendente');
            return;
          }
          
          console.log(`${pendingMessages.length} mensagens pendentes recebidas`);
          
          // Agrupa mensagens por conversation_id
          const messagesByConv = {};
          pendingMessages.forEach(msg => {
            if (!messagesByConv[msg.conversation_id]) {
              messagesByConv[msg.conversation_id] = [];
            }
            messagesByConv[msg.conversation_id].push(msg);
          });
          
          // Mostra notifica√ß√£o
          let notificationText = `üì¨ Voc√™ tem ${pendingMessages.length} mensagem(ns) pendente(s):\n\n`;
          Object.keys(messagesByConv).forEach(convId => {
            const msgs = messagesByConv[convId];
            const senders = [...new Set(msgs.map(m => m.sender_username))].join(', ');
            notificationText += `‚Ä¢ Conversa ${convId}: ${msgs.length} msg(ns) de ${senders}\n`;
          });
          
          alert(notificationText);
          
          // Recarrega as conversas para atualizar as mensagens
          loadConversations();
        })
        .catch(err => console.error('Erro ao carregar mensagens pendentes:', err));
    }

    // Fun√ß√£o para fazer logout (sair da aplica√ß√£o)
    function logout() {
      console.log("üî¥ LOGOUT iniciado");
      
      // Para atualiza√ß√µes autom√°ticas
      stopReadStatusUpdates();
      
      // Limpar localStorage
      localStorage.removeItem('chat_token');
      localStorage.removeItem('chat_username');
      localStorage.removeItem('chat_conversationId');
      
      // Limpar intervalos
      if (presenceInterval) {
        clearInterval(presenceInterval);
        presenceInterval = null;
      }
      
      // Limpar dados
      token = null;
      username = null;
      conversationId = null;
      
      // Fecha WebSocket (isso j√° marca como offline automaticamente)
      if (ws) {
        ws.close();
        ws = null;
      }
      
      // Limpar interface
      document.getElementById('login-area').style.display = '';
      document.getElementById('conversation-area').style.display = 'none';
      document.getElementById('chat-area').style.display = 'none';
      document.getElementById('register-area').style.display = 'none';
      document.getElementById('app-title').innerText = 'üéØ Chat';
      document.getElementById('login-status').innerText = '';
      document.getElementById('username').value = '';
      document.getElementById('password').value = '';
      document.getElementById('token-box').style.display = 'none';
      document.getElementById('token-box').innerHTML = '';
      
      console.log('‚úÖ Logout realizado com sucesso!');
    }

    function createConversation() {
      const participants = document.getElementById('participants').value.split(',').map(s => s.trim()).filter(Boolean);
      if (!participants.includes(username)) participants.push(username);
      const type = document.getElementById('conv-type').value;
      
      // Normalizar participantes: ordenar alfabeticamente para compara√ß√£o consistente
      const normalizedParticipants = [...participants].sort();
      
      console.log('üîç Verificando se j√° existe conversa com:', normalizedParticipants);
      
      // Primeiro, buscar todas as conversas para verificar se j√° existe
      fetch(`http://localhost:3003/api/v1/users/${username}/conversations`, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        }
      })
        .then(res => res.json())
        .then(data => {
          const conversations = data.conversations || [];
          console.log('üìã Total de conversas encontradas:', conversations.length);
          
          // Procurar conversa existente com os mesmos participantes
          const existingConv = conversations.find(conv => {
            const convParticipants = (conv.participants || []).sort();
            console.log('  Comparando:', {
              buscando: normalizedParticipants,
              encontrado: convParticipants,
              id: conv.id
            });
            
            // Verifica se tem o mesmo n√∫mero de participantes
            if (convParticipants.length !== normalizedParticipants.length) return false;
            
            // Verifica se todos os participantes est√£o presentes (arrays j√° ordenados)
            const match = normalizedParticipants.every((p, i) => convParticipants[i] === p);
            if (match) console.log('  ‚úÖ MATCH encontrado! ID:', conv.id);
            return match;
          });
          
          if (existingConv) {
            // Conversa j√° existe, abre ela em vez de criar nova
            console.log('‚úÖ Conversa j√° existe com ID:', existingConv.id, '- Abrindo...');
            document.getElementById('conv-status').innerText = 'Abrindo conversa existente (ID: ' + existingConv.id + ')';
            selectConversation(existingConv.id);
          } else {
            // N√£o existe, criar nova
            console.log('üìù Criando nova conversa...');
            fetch('http://localhost:3003/api/v1/conversations', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + token
              },
              body: JSON.stringify({ participants, type })
            })
              .then(res => {
                if (!res.ok) {
                  if (res.status === 401) {
                      console.error("401 em createConversation - ignorando logout");
                      // logout();
                  }
                  throw new Error(`HTTP ${res.status}`);
                }
                return res.json();
              })
              .then(data => {
                conversationId = data.conversationId;
                localStorage.setItem('chat_conversationId', conversationId);
                console.log('‚úÖ Nova conversa criada:', conversationId);
                console.log('‚úÖ Salvo no localStorage:', localStorage.getItem('chat_conversationId'));
                console.log('‚úÖ Vari√°vel conversationId:', conversationId);
                document.getElementById('conv-status').innerText = 'Conversa criada!';
                document.getElementById('conversation-area').style.display = 'none';
                document.getElementById('chat-area').style.display = 'flex';
                document.getElementById('conv-id').innerText = conversationId;
                connectWS();
                loadMessages();
                loadParticipants();
                loadConversations(); // Atualiza lista ap√≥s criar
              });
          }
        })
        .catch(err => {
          console.error('Erro ao verificar/criar conversa:', err);
          document.getElementById('conv-status').innerText = 'Erro: ' + err.message;
        });
    }
    function loadParticipants() {
      fetch(`http://localhost:3003/api/v1/conversations/${conversationId}/participants`, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        }
      })
        .then(res => {
          if (!res.ok) {
            if (res.status === 401) {
                console.error("401 em loadParticipants - ignorando logout");
                // logout();
            }
            throw new Error(`HTTP ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          const users = data.participants || [];
          const ul = document.getElementById('participants-list');
          ul.innerHTML = '';
          users.forEach(user => {
            const li = document.createElement('li');
            li.innerText = user;
            ul.appendChild(li);
          });
        });
    }

    function loadMessages() {
      fetch(`http://localhost:3003/api/v1/conversations/${conversationId}/messages`, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        }
      })
        .then(res => {
          if (!res.ok) {
            if (res.status === 401) {
              console.error("401 em loadMessages - ignorando logout");
              // logout();
            }
            throw new Error(`HTTP ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          const messages = data.messages || [];
          const ul = document.getElementById('messages');
          
          // Salva posi√ß√£o do scroll antes de atualizar
          const chatContainer = document.getElementById('chat');
          const wasAtBottom = chatContainer.scrollHeight - chatContainer.scrollTop <= chatContainer.clientHeight + 100;
          const scrollPos = chatContainer.scrollTop;
          
          ul.innerHTML = '';
          messages.forEach(msg => {
            const li = document.createElement('li');
            const isMe = msg.sender_username === username;
            li.className = isMe ? 'me' : 'other';
            if (msg.id) li.dataset.messageId = msg.id;
            
            // Se √© arquivo (type === 'file' e tem file_id)
            if (msg.type === 'file' && msg.file_id) {
              const fileName = msg.file_key ? msg.file_key.split('/').pop() : 'arquivo';
              const fileSize = msg.size ? `(${(msg.size / 1024).toFixed(2)} KB)` : '';
              
              // Se n√£o for minha mensagem, mostra nome
              if (!isMe) {
                const userName = document.createElement('div');
                userName.style.fontWeight = 'bold';
                userName.style.fontSize = '13px';
                userName.style.marginBottom = '2px';
                userName.style.color = '#25d366';
                userName.innerText = msg.sender_username;
                li.appendChild(userName);
              }
              
              const downloadBtn = document.createElement('button');
              downloadBtn.innerHTML = `üìÑ ${fileName} <br><small>${fileSize}</small><br>‚¨áÔ∏è Clique para baixar`;
              downloadBtn.style.cssText = `
                background: #f8f9fa;
                color: #2c3e50;
                border: 1px solid #bdc3c7;
                padding: 10px 15px;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 500;
                margin-top: 8px;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 5px;
                width: 100%;
                text-align: center;
                transition: all 0.2s;
              `;
              downloadBtn.onclick = () => downloadFile(msg.file_id, fileName);
              downloadBtn.onmouseover = () => {
                downloadBtn.style.background = '#e9ecef';
                downloadBtn.style.borderColor = '#aab7b8';
              };
              downloadBtn.onmouseout = () => {
                downloadBtn.style.background = '#f8f9fa';
                downloadBtn.style.borderColor = '#bdc3c7';
              };
              
              li.appendChild(downloadBtn);
              
              // Status de leitura para arquivos
              if (isMe && msg.id) {
                const readStatus = document.createElement('span');
                readStatus.className = msg.is_read ? 'read-status read' : 'read-status';
                readStatus.innerHTML = msg.is_read ? '‚úì‚úì' : '‚úì';
                li.appendChild(readStatus);
              }
            } else {
              // Mensagem de texto normal
              // Se n√£o for minha mensagem, mostra nome
              if (!isMe) {
                const userName = document.createElement('div');
                userName.style.fontWeight = 'bold';
                userName.style.fontSize = '13px';
                userName.style.marginBottom = '2px';
                userName.style.color = '#25d366';
                userName.innerText = msg.sender_username;
                li.appendChild(userName);
              }
              
              const msgText = document.createElement('span');
              msgText.className = 'message-text';
              msgText.innerText = msg.content;
              li.appendChild(msgText);
              
              // Status de leitura para mensagens de texto
              if (isMe && msg.id) {
                const readStatus = document.createElement('span');
                readStatus.className = msg.is_read ? 'read-status read' : 'read-status';
                readStatus.innerHTML = msg.is_read ? '‚úì‚úì' : '‚úì';
                li.appendChild(readStatus);
              }
            }
            
            ul.appendChild(li);
            
            // Se n√£o √© minha mensagem, marcar como lida
            if (!isMe && msg.id) {
              markMessageAsRead(msg.id);
            }
          });
          
          // Restaura posi√ß√£o do scroll ou vai para o final se estava no final
          setTimeout(() => {
            if (wasAtBottom) {
              chatContainer.scrollTop = chatContainer.scrollHeight;
            } else {
              chatContainer.scrollTop = scrollPos;
            }
          }, 10);
        })
        .catch(err => {
          console.error('Erro ao carregar mensagens:', err);
          console.error('Stack completo:', err.stack);
          // N√£o fazer nada de dram√°tico, apenas registrar
        });
    }

    function downloadFile(fileId, fileName) {
      console.log(`Baixando arquivo ${fileName} (ID: ${fileId})`);
      
      fetch(`http://localhost:3003/api/v1/files/${fileId}/download`, {
        headers: {
          'Authorization': 'Bearer ' + token
        }
      })
        .then(res => {
          if (!res.ok) {
            if (res.status === 401) {
                console.error("401 em downloadFile - ignorando logout");
                // logout();
            }
            throw new Error(`HTTP ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          if (data.url) {
            console.log('URL de download gerada:', data.url);
            window.open(data.url, '_blank');
          } else {
            alert('Erro ao gerar URL de download');
          }
        })
        .catch(err => {
          console.error('Erro ao obter URL de download:', err);
          alert('Erro ao baixar arquivo: ' + err.message);
        });
    }

    function sendMessage() {
      const content = document.getElementById('msg').value;
      if (!content) return;
      fetch('http://localhost:3003/api/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify({ conversationId, content })
      })
        .then(res => {
          if (!res.ok) {
            if (res.status === 401) {
                console.error("401 em sendMessage - ignorando logout");
                // logout();
            }
            throw new Error(`HTTP ${res.status}`);
          }
          return res.json();
        })
        .then(() => {
          // N√£o adiciona aqui, aguarda vir pelo WebSocket com ID correto
          document.getElementById('msg').value = '';
          loadConversations(); // Atualiza lista ao enviar mensagem
          
          // Recarrega mensagens para pegar o ID correto da mensagem enviada
          setTimeout(() => loadMessages(), 500);
        })
        .catch(err => {
        console.error('Erro ao enviar mensagem:', err);
        alert('Erro ao enviar mensagem: ' + err.message);
      });
    }

    // Fun√ß√µes para Upload de Arquivo
    function triggerFileInput() {
      if (!conversationId) {
        alert('Selecione uma conversa primeiro');
        return;
      }
      document.getElementById('file-input').click();
    }

    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      console.log('Arquivo selecionado:', file.name, file.size);
      uploadFile(file);
      document.getElementById('file-input').value = '';
    }

    async function uploadFile(file) {
      try {
        // PASSO 1: Iniciar upload multipart
        console.log('1/4 Inicializando upload...');
        const initResponse = await fetch('http://localhost:3003/api/v1/files/init', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
          },
          body: JSON.stringify({
            filename: file.name,
            size: file.size,
            checksum: 'auto',
            conversationId: parseInt(conversationId)
          })
        });

        if (!initResponse.ok) {
          throw new Error(`Init falhou: ${initResponse.status}`);
        }

        const initData = await initResponse.json();
        console.log('2/4 Upload iniciado, uploadId:', initData.uploadId);

        // PASSO 2: Obter presigned URL para parte
        const partResponse = await fetch('http://localhost:3003/api/v1/files/part-url', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
          },
          body: JSON.stringify({
            key: initData.key,
            uploadId: initData.uploadId,
            partNumber: 1
          })
        });

        if (!partResponse.ok) {
          throw new Error(`Part-URL falhou: ${partResponse.status}`);
        }

        const partData = await partResponse.json();
        console.log('3/4 URL de upload gerada');

        // PASSO 3: Upload direto para MinIO via presigned URL
        const uploadResponse = await fetch(partData.url, {
          method: 'PUT',
          body: file,
          headers: {
            'Content-Type': file.type || 'application/octet-stream'
          }
        });

        if (!uploadResponse.ok) {
          throw new Error(`Upload para MinIO falhou: ${uploadResponse.status}`);
        }

        const etag = uploadResponse.headers.get('etag') || '""';
        console.log('4/4 Completando upload, ETag:', etag);

        // PASSO 4: Completar upload
        const completeResponse = await fetch('http://localhost:3003/api/v1/files/complete', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + token
          },
          body: JSON.stringify({
            key: initData.key,
            uploadId: initData.uploadId,
            parts: [{ PartNumber: 1, ETag: etag }],
            conversationId: parseInt(conversationId),
            filename: file.name
          })
        });

        if (!completeResponse.ok) {
          throw new Error(`Complete falhou: ${completeResponse.status}`);
        }

        console.log('‚úÖ Arquivo enviado com sucesso!');
        loadMessages();
        loadConversations();
        // alert("Arquivo enviado! Verifique se o app fecha agora.");
      } catch (err) {
        console.error('Erro ao enviar arquivo:', err);
        alert('Erro ao enviar arquivo: ' + err.message);
      }
    }

    // Adicionar manipulador global de erros n√£o tratados
    window.addEventListener('error', (event) => {
      console.error('Erro global capturado:', event.error);
      console.error('Stack:', event.error?.stack);
    });

    window.addEventListener('unhandledrejection', (event) => {
      console.error('Promise rejection n√£o tratada:', event.reason);
      event.preventDefault(); // Previne que o app morra
    });

    function connectWS() {
      if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
        console.warn('‚ö†Ô∏è WebSocket j√° existe, n√£o criando novo');
        return;
      }
      console.log('üîå Criando novo WebSocket...');
      ws = new WebSocket('ws://localhost:3003/?token=' + token);
      ws.onmessage = function (e) {
        try {
          const data = JSON.parse(e.data);
          
          // Mensagem de boas-vindas removida para n√£o poluir o chat
          // if (data.type === 'welcome') {
          //   addSystemMsg('Conectado como ' + data.user);
          // }
          
        if (data.type === 'new_message' && data.message.conversation_id == conversationId) {
          // Se for arquivo, recarrega mensagens para exibir corretamente
          if (data.message.type === 'file') {
            console.log('‚úÖ Recebido arquivo via WS:', data.message);
            try {
              loadMessages();
            } catch (err) {
              console.error('‚ùå Erro ao carregar mensagens ap√≥s arquivo:', err);
            }
          } else {
            // Mensagem de texto: adiciona diretamente
            addMsg(data.message.sender_username, data.message.content, data.message.id);
          }
        }
        
        if (data.type === 'message_status') {
          console.log('‚úÖ Status da mensagem recebido:', data.message);
        }
        
        // Notifica√ß√£o de que mensagem foi lida
        if (data.type === 'message_read') {
          console.log('‚úì‚úì Mensagem lida:', data.message_id, 'por', data.reader);
          updateReadStatus(data.message_id);
        }
        
        // ATUALIZA√á√ÉO: Manipular eventos de presen√ßa via WebSocket
          if (data.type === 'presence_update') {
            console.log('Atualiza√ß√£o de presen√ßa (WS):', data);
            // Recarrega a lista de usu√°rios apenas quando houver mudan√ßa real
            loadOnlineUsers();
          }
        } catch (err) {
          console.error('‚ùå ERRO CR√çTICO ao processar mensagem WebSocket:', err);
          console.error('Dados recebidos:', e.data);
          console.error('Stack:', err.stack);
          alert('ERRO ao processar WebSocket: ' + err.message);
        }
      };
      ws.onclose = function (event) {
        console.error('üî¥ WebSocket FECHADO!', event);
        console.error('C√≥digo:', event.code, 'Raz√£o:', event.reason, 'Clean:', event.wasClean);
        console.log('üîç conversationId no momento do close:', conversationId, 'type:', typeof conversationId);
        console.log('üîç conversationId no localStorage:', localStorage.getItem('chat_conversationId'));
        
        // Pega o ID do localStorage que √© a fonte da verdade
        const savedConvId = localStorage.getItem('chat_conversationId');
        
        // RECONECTAR AUTOMATICAMENTE ap√≥s 500ms
        if (savedConvId && token) {
          console.log('üîÑ Reconectando em 500ms...');
          const currentConvId = parseInt(savedConvId);
          setTimeout(() => {
            if (token && currentConvId) {
              console.log('üîÑ Reconectando WebSocket e recarregando dados para conversa:', currentConvId);
              
              // Garante que est√° na conversa certa
              conversationId = currentConvId;
              document.getElementById('conv-id').innerText = currentConvId;
              
              connectWS();
              loadMessages();
              loadParticipants();
              loadOnlineUsers();
            }
          }, 500);
        }
      };
      ws.onerror = function (error) {
        console.error('üî¥ WebSocket ERROR:', error);
      };
    }

    function addMsg(user, content, messageId = null, isRead = false) {
      const ul = document.getElementById('messages');
      const li = document.createElement('li');
      const isMe = user === username;
      li.className = isMe ? 'me' : 'other';
      if (messageId) li.dataset.messageId = messageId;
      
      // Se n√£o for minha mensagem, mostra o nome do usu√°rio
      if (!isMe) {
        const userName = document.createElement('div');
        userName.style.fontWeight = 'bold';
        userName.style.fontSize = '13px';
        userName.style.marginBottom = '2px';
        userName.style.color = '#25d366';
        userName.innerText = user;
        li.appendChild(userName);
      }
      
      const msgText = document.createElement('span');
      msgText.className = 'message-text';
      msgText.innerText = content;
      li.appendChild(msgText);
      
      // Se for minha mensagem, adiciona checkmarks
      if (isMe && messageId) {
        const readStatus = document.createElement('span');
        readStatus.className = isRead ? 'read-status read' : 'read-status';
        readStatus.innerHTML = isRead ? '‚úì‚úì' : '‚úì'; // ‚úì‚úì = lido, ‚úì = entregue
        li.appendChild(readStatus);
      }
      
      ul.appendChild(li);
      
      // Se n√£o √© minha mensagem e tenho messageId, marcar como lida
      if (!isMe && messageId) {
        markMessageAsRead(messageId);
      }
    }

    function addSystemMsg(msg) {
      const ul = document.getElementById('messages');
      const li = document.createElement('li');
      li.className = 'system';
      li.innerText = msg;
      ul.appendChild(li);
    }
    
    // Marca mensagem como lida
    function markMessageAsRead(messageId) {
      // S√≥ marca como lida se tiver messageId, token E estiver na conversa
      if (!messageId || !token || !conversationId) return;
      
      // Verifica se a √°rea de chat est√° vis√≠vel (usu√°rio realmente na conversa)
      const chatArea = document.getElementById('chat-area');
      if (!chatArea || chatArea.style.display === 'none') {
        console.log(`‚ö†Ô∏è N√£o marca como lida - usu√°rio fora da conversa`);
        return;
      }
      
      fetch(`http://localhost:3003/api/v1/messages/${messageId}/read`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        }
      })
      .then(res => {
        if (res.ok) {
          console.log(`‚úì Mensagem ${messageId} marcada como lida`);
        }
      })
      .catch(err => console.error('Erro ao marcar como lida:', err));
    }
    
    // Atualiza status visual de leitura
    function updateReadStatus(messageId) {
      const li = document.querySelector(`[data-message-id="${messageId}"]`);
      if (li) {
        const readStatus = li.querySelector('.read-status');
        if (readStatus) {
          readStatus.classList.add('read');
          readStatus.innerHTML = '‚úì‚úì'; // Dois checks azuis
        }
      }
    }
    
    // Inicia atualiza√ß√£o peri√≥dica do status de leitura
    function startReadStatusUpdates() {
      // Limpa intervalo anterior se existir
      if (readStatusInterval) {
        clearInterval(readStatusInterval);
      }
      
      // Atualiza a cada 3 segundos
      readStatusInterval = setInterval(() => {
        // S√≥ atualiza se estiver na conversa E a √°rea de chat estiver vis√≠vel
        const chatArea = document.getElementById('chat-area');
        if (conversationId && token && chatArea && chatArea.style.display !== 'none') {
          loadMessages(); // Recarrega mensagens para pegar status atualizado
        }
      }, 3000);
      
      console.log('üîÑ Atualiza√ß√£o de status de leitura iniciada');
    }
    
    // Para atualiza√ß√£o peri√≥dica
    function stopReadStatusUpdates() {
      if (readStatusInterval) {
        clearInterval(readStatusInterval);
        readStatusInterval = null;
        console.log('‚ùå Atualiza√ß√£o de status de leitura parada');
      }
    }
  </script>



</body>

</html>